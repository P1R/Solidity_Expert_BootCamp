# Homework 10

## Optimisation 2

### 1. Why are negative numbers more expensive to store than positive numbers ?

#### Answer

```Solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

contract Lesson10_1 {
    
    function storePositive() external {
        assembly {
            sstore(0x40, 1)
        }
    }
    
    function storeNegative() external {
        assembly {
            sstore(0x50, not(1))
        }
    }
}
```

![image](https://github.com/P1R/Solidity_Expert_BootCamp/assets/706259/efbba4e5-956c-488c-8b6e-ddb4f60d5b98)

Img1.

Following the Code1, Function StorePositive the push of 1, push of 0x40 offset give a total of 6 gas units, 3 gas unit respectively per push, and the sstore takes 22100 gas units, aht the end the whole storePositive Function requires 22114 gas units as shown in the img1.  

![image](https://github.com/P1R/Solidity_Expert_BootCamp/assets/706259/80ff3bb1-614e-4caa-bab3-673f8ff737a3)


Img2. 

Following the Code2, Function StoreNegative the push of 1, the push of a not and the push of 0x50 offset give a total of 9 gas units, 3 gas unit respectively per push, and the sstore takes 22100 gas units, aht the end the whole storePositive Function requires 22117 gas units as shown in the img2.  

![image](https://github.com/P1R/Solidity_Expert_BootCamp/assets/706259/63f2e0c0-56a9-4380-ac85-6a39dc35d912)
Img3. Shows the storage offsets with the positive 1 and negative 1.

### 2. Test the following statements in Remix, which is cheaper and why ?
> Assume that the denominator can never be zero.

#### 2.1

```Solidity
result = numerator / demoninator;
```

#### 2.2

```Solidity
assembly {
    result := div(numerator, demoninator)
}
```
#### Answer
```Solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

contract Lesson10_2 {
 
    function DivSol() pure external {
        uint numerator = 10;
        uint demoninator = 2;
        uint result;

        result = numerator / demoninator;
    }
    
    function DivASM() pure external {
        assembly {
            let numerator := 10
            let demoninator := 2
            let result 
            result := div(numerator, demoninator)
        }
    }
}
```
Code1. Implementation of the statements

![image](https://github.com/P1R/Solidity_Expert_BootCamp/assets/706259/1de1dd60-9b12-45e6-9e45-1263bd928574)
2.1 Gas Consumption

![image](https://github.com/P1R/Solidity_Expert_BootCamp/assets/706259/945ff9a5-192d-4538-a787-9a994ce86521)
2.2 Gas Consumption

In regards the code1 which implement the statements from 2.1 and 2.2 and by testing in remix, I reached the following explination:

The first function uses Solidity's division operator to perform a simple division operation, whereas the second function uses assembly code to perform the same operation using the div opcode. It is noted that the Solidity division operation consumes significantly more gas than the div opcode, which is due to the Solidity compiler generating more complex EVM bytecode to perform the division operation. As a result, it is recommended to use assembly code when gas efficiency is a concern, as it allows for more direct control over the generated EVM bytecode.

>Notice the amount of opcodes generated by the solidity `/` operand, we get a huge amount of OPCodes.

## References

1. Lesson 10, Expert Solidity Bootcamp, 2023-05-10
